# V1.2 版本需求文档

## 概述

需求文档基于V1.1版本，主要增加告警模块。由于项目已有时序检查节点状态的定时任务（定义在 @code/backend/backend/celery.py），我们给后端增加一个alert模块，提供完整的告警管理功能。告警模块提供接口供其他模块调用，当定时任务检测到节点异常时，会调用接口将异常信息存储到alert模块的model中。

同时，在前端 @code/frontend/src/views/monitor/alerts 中增加index.vue页面，用来展示告警数据库的数据。

## 主要功能

### 1. 告警唯一性管理
- 通过数据库约束和应用层逻辑解决告警重复问题
- 对于相同节点、相同类型的告警，如果已有未关闭的告警，则不创建新告警，而是更新现有告警的最后发生时间
- 告警状态包括：
  - **开启(OPEN)**：告警已触发但尚未处理
  - **已关闭(CLOSED)**：问题已解决或手动关闭，告警不再活跃
  - **已确认(ACKNOWLEDGED)**：告警已被运维人员确认，但问题可能仍然存在

### 2. 配置驱动的告警规则
- 通过YAML配置文件(@code/backend/config/alert_rules.yaml)定义告警规则
- 支持多种告警类型：响应时间过慢、健康检查失败、服务不可用、连接超时等
- 配置项包括：
  - 时间窗口（如过去5分钟的平均响应时间）
  - 聚合方式（avg, max, min等）
  - 阈值条件（在condition中定义，如"avg_response_time > 1000"）
  - 严重程度（LOW, MEDIUM, HIGH, CRITICAL）
  - 消息模板等

### 3. 后端功能
- **Alert模型**：定义告警数据结构，包含节点ID、告警类型、状态、严重程度等字段
- **AlertView**：提供CRUD操作接口（获取列表、创建、更新、删除、获取详情）
- **AlertTypesView**：提供告警类型接口
- **配置解析器**：解析YAML配置文件中的告警规则
- **定时任务**：
  - `check_all_alerts`：基于配置文件规则检查所有告警
  - 按配置的时间间隔执行告警检查
- **告警操作**：
  - **确认告警**：将告警状态从"开启"改为"已确认"，表示运维人员已注意到此告警
  - **关闭告警**：将告警状态从"开启"或"已确认"改为"已关闭"，表示问题已解决或无需处理
  - **自动关闭**：当监控数据恢复正常时，系统自动将相关告警状态改为"已关闭"

### 4. 前端功能
- **告警页面**：@code/frontend/src/views/monitor/alerts/index.vue
  - 支持按状态、严重程度、类型、节点ID等条件筛选
  - 展示告警列表（标题、节点ID、类型、严重程度、状态、时间等）
  - 提供告警操作功能：
    - **确认告警**：将告警状态改为"已确认"，标识运维人员已注意到此告警
    - **关闭告警**：将告警状态改为"已关闭"，标识问题已解决
    - **详情查看**：查看告警详细信息
  - 支持动态加载告警类型的筛选选项
- **API封装**：@code/frontend/src/api/monitor/index.ts
  - 提供告警相关API函数（getAlerts, getAlert, createAlert, updateAlert, deleteAlert, getAlertTypes）

### 5. 告警策略
- 支持基于时间窗口的聚合计算（如过去5分钟的平均响应时间）
- 支持不同类型的聚合方式（平均值、最大值、最小值）
- 支持动态阈值提取（从配置条件中自动提取阈值）
- 支持告警恢复检测（当问题解决时自动关闭相关告警）
- 支持告警状态管理（开启、确认、关闭），允许运维人员按需处理告警

## 定时任务集成
- 在@code/backend/backend/celery.py中添加`check_all_alerts`任务
- 任务按配置的间隔时间执行，检查所有节点的告警状态
- 基于配置文件中的规则进行告警判断和处理

## 数据模型
- Alert模型继承BaseModel，包含uuid主键、软删除字段、时间戳等
- 支持告警状态管理：
  - **开启(OPEN)**：告警已触发但尚未处理
  - **已关闭(CLOSED)**：问题已解决或手动关闭，告警不再活跃
  - **已确认(ACKNOWLEDGED)**：告警已被运维人员确认，但问题可能仍然存在
- 包含唯一约束防止重复告警
- 支持关联创建者和确认者
- 支持告警严重程度分级（LOW/MEDIUM/HIGH/CRITICAL）
- 支持记录告警发生、确认、解决时间戳

## 配置驱动的告警处理流程

以 `response_time_slow` 规则为例，详细说明从YAML配置到实际告警的处理流程：

### 1. 配置加载
- `AlertConfigParser` 读取 `alert_rules.yaml` 文件
- 将 `response_time_slow` 规则解析为 `AlertRule` 对象

### 2. 定时任务触发
- Celery 按 `check_interval`（如 "10m"）执行 `check_all_alerts` 任务
- 任务获取所有启用的告警规则

### 3. 数据获取和聚合
- 根据 `time_window`（如 "5m"）获取最近5分钟的健康记录
- 根据 `aggregation`（如 "avg"）计算聚合值（如平均响应时间）

### 4. 条件评估
- 构建评估上下文，包含节点信息、聚合值等数据
- 评估 `condition`（如 "avg_response_time > 1000"）
- 使用 `extract_threshold_from_condition` 函数从条件中提取阈值（1000）

### 5. 告警判断和创建
- 如果条件评估为 `True`，使用 `message` 模板格式化告警消息
- 调用 `create_or_update_alert` 创建或更新告警记录
- 确保告警唯一性，避免重复创建
- 新告警状态默认为"开启(OPEN)"，等待运维处理

### 6. 告警状态管理
- **开启(OPEN)**：告警触发后的初始状态
- **已确认(ACKNOWLEDGED)**：运维人员手动确认告警后改变状态，表示已注意到此告警
- **已关闭(CLOSED)**：问题解决或手动关闭后改变状态，表示告警结束
- **自动状态转换**：当监控数据恢复正常时，系统自动将相关告警状态改为"已关闭"

### 7. 完整数据流
```
YAML配置 → AlertRule对象 → check_all_alerts任务 → 
获取时间窗口数据 → 计算聚合值 → 提取阈值 → 
评估条件 → 格式化消息 → 创建/更新告警 → 存储 → 前端展示 → 
运维处理（确认/关闭）→ 状态管理 → 自动恢复检测
```

通过这种方式，实现了完全配置驱动的告警系统，无需修改代码即可调整告警策略。